---
layout: post
category: tools
---

<script type="text/javascript">
        /*
         * Implementation to calculate the CRC value for a given string / string of bytes.
         * Sunshine, May 2k15
         * www.sunshine2k.de || www.bastian-molkenthin.de
         */
        "use strict";

        /*
         * Struct to contain one instance of a CRC algorithm model */
        function CrcModel(width, name, polynomial, initial, finalXor, inputReflected, resultReflected) {
            this.width = 16;
            this.name = "CRC16_A";
            this.polynomial = 0x1021;
            this.initial = 0xC6C6;
            this.finalXor = 0x0000;
            this.inputReflected = true;
            this.resultReflected = true;
        }

        /* Known CRC algorihtms */
        var CrcDatabase = [
            new CrcModel(16, "CRC16_A", 0x1021, 0xC6C6, 0x0000, true, true),
            new CrcModel(16, "CRC16_XMODEM", 0x1021, 0x0000, 0x0000, false, false),
        ];
             
               
        /* two constructors supported:
            - new Crc(width, polynomial, initialVal, finalXorVal, inputReflected, resultReflected)
            - new Crc(width, crcModel)
        */
        var Crc = function (width, polynomial, initialVal, finalXorVal, inputReflected, resultReflected) {            
            /* private variables */
            // crc model variables
            var width;
            var polynomial;
            var initialVal;
            var finalXorVal;
            var inputReflected;
            var resultReflected;

            var crcTable;       // lookup table
            var castMask;
            var msbMask;

            /* 'constructor' */
            if (arguments.length == 2 && typeof arguments[1] === "object") {
                width = arguments[0];
                polynomial = arguments[1].polynomial;
                initialVal = arguments[1].initial;
                finalXorVal = arguments[1].finalXor;
                inputReflected = arguments[1].inputReflected;
                resultReflected = arguments[1].resultReflected;
            }
            else if (arguments.length == 6) {
                width = arguments[0];
                polynomial = arguments[1];
                initialVal = arguments[2];
                finalXorVal = arguments[3];
                inputReflected = arguments[4];
                resultReflected = arguments[5];
            }
            else {
                new Error("Invalid arguments");
            }

            switch (width)
            {
                case 8: castMask = 0xFF; break;
                case 16: castMask = 0xFFFF; break;
                case 32: castMask = 0xFFFFFFFF; break;
                default: throw "Invalid CRC width"; break;
            }
            msbMask = 0x01 << (width - 1)
            /* 'constructor' END */

            this.calcCrcTable = function ()
            {
                crcTable = new Array(256);

                for (var divident = 0; divident < 256; divident++)
                {
                    var currByte = (divident << (width - 8)) & castMask;
                    for (var bit = 0; bit < 8; bit++)
                    {
                        if ((currByte & msbMask) != 0)
                        {
                            currByte <<= 1;
                            currByte ^= polynomial;
                        }
                        else
                        {
                            currByte <<= 1;
                        }
                    }
                    crcTable[divident] = (currByte & castMask);
                }
            }

            if (!this.crcTable)
            {
                this.calcCrcTable();
            }

            this.compute = function (bytes)
            {
                var crc = initialVal;
                for (var i = 0; i < bytes.length; i++)
                {

                    var curByte = bytes[i] & 0xFF;

                    if (inputReflected)
                    {
                        curByte = new CrcUtil().Reflect8(curByte);
                    }

                    /* update the MSB of crc value with next input byte */
                    crc = (crc ^ (curByte << (width - 8))) & castMask;
                    /* this MSB byte value is the index into the lookup table */
                    var pos = (crc >> (width - 8)) & 0xFF;
                    /* shift out this index */
                    crc = (crc << 8) & castMask;
                    /* XOR-in remainder from lookup table using the calculated index */
                    crc = (crc ^ crcTable[pos]) & castMask;
                }

                if (resultReflected)
                {
                    crc = new CrcUtil().ReflectGeneric(crc, width);
                }
                return ((crc ^ finalXorVal) & castMask);
            }

            this.getLookupTable = function ()
            {
                return crcTable;
            }
        };

        /*
         * String utility functions
         */
        var StringUtil = function () {
            if (StringUtil.prototype._singletonInstance)
            {
                return StringUtil.prototype._singletonInstance;
            }
            StringUtil.prototype._singletonInstance = this;

            /*
             * Converts a string into an array of bytes.
             * This is not really correct as an character (unicode!) does not always fit into a byte, so the
             * character value might be cut!
             */
            this.getCharacterByteArrayFromString = function (str)
            {
                var i, charVal;
                var bytes = [];
                for (i = 0; i < str.length; i++)
                {
                    charVal = str.charCodeAt(i);
                    if (charVal < 256)
                    {
                        bytes[i] = str.charCodeAt(i);
                    }
                }
                return bytes;
            };

            /*
             * Get the given number as hexadecimal string
             */
            this.getNumberAsHexStr = function (num)
            {
                var tempStr = num.toString(16).toUpperCase();
                return ("0x" + tempStr);
            }

            this.getNumberAsHexStr = function (num, widthInBits)
            {
                var tempStr = num.toString(16).toUpperCase();
                while (tempStr.length < (widthInBits >> 2))
                {
                    tempStr = '0' + tempStr;
                }
                return ("0x" + tempStr);
            }

            /*
             * Get the given 32bit number as hexadecimal string
             */
            this.getNumberAsHexStr32 = function (num)
            {
                var valueHigh = num >>> 16;
                var valueLow = num & 0x0000FFFF;
                return ("0x" + valueHigh.toString(16).toUpperCase() + valueLow.toString(16).toUpperCase());
            }

            this.getNumberAsHexStr32FixedWidth = function (num)
            {
                var valueHigh = num >>> 16;
                valueHigh = valueHigh.toString(16).toUpperCase()
                while (valueHigh.length < 4)
                {
                    valueHigh = '0' + valueHigh;
                }

                var valueLow = num & 0x0000FFFF;
                valueLow = valueLow.toString(16).toUpperCase()
                while (valueLow.length < 4)
                {
                    valueLow = '0' + valueLow;
                }

                return ("0x" + valueHigh + valueLow);
            }
            
            var lastErrToken;
            /*
             * Get value of token where a call to getCharacterByteArrayFromByteString might have failed. */
            this.getLastErrorToken = function ()
            {
                return lastErrToken;
            }

            /*
             * Converts a string of byte values into an array of bytes.
             * Returns undefined if an errors occurs. The erroneous token can be retrieved by getLastErrorToken().
             */
            this.getCharacterByteArrayFromByteString = function (str)
            {
                var bytes = [];
                var splitStr = str.split(" ");
                for (var i = 0; i < splitStr.length; i++)
                {
                    var byteStr = splitStr[i];
                    if (byteStr.substr(0, 2) === "0x")
                    {
                        byteStr = byteStr.substr(2, byteStr.length - 2);
                    }

                    if (byteStr === " " || byteStr === "")
                        continue;

                    var b = parseInt(byteStr, 16);
                    if (b === NaN || b === undefined)
                    {
                        lastErrToken = byteStr;
                        return undefined;
                    }
                    else
                    {
                        if (b < 256)
                        {
                            bytes[i] = b;
                        }
                        else
                        {
                            lastErrToken = byteStr;
                            return undefined;
                        }

                    }
                }
                return bytes;
            }

        };

        /*
         * CRC utility functions to reflect numbers.
         */
        var CrcUtil = function ()
        {
            /* singleton */
            if (CrcUtil.prototype._singletonInstance)
            {
                return CrcUtil.prototype._singletonInstance;
            }
            CrcUtil.prototype._singletonInstance = this;

            this.Reflect8 = function(val)
            {
                var resByte = 0;

                for (var i = 0; i < 8; i++)
                {
                    if ((val & (1 << i)) != 0)
                    {
                        resByte |= ( (1 << (7 - i)) & 0xFF);
                    }
                }

                return resByte;
            }

            this.Reflect16 = function (val)
            {
                var resByte = 0;

                for (var i = 0; i < 16; i++)
                {
                    if ((val & (1 << i)) != 0)
                    {
                        resByte |= ((1 << (15 - i)) & 0xFFFF);
                    }
                }

                return resByte;
            }

            this.Reflect32 = function (val)
            {
                var resByte = 0;

                for (var i = 0; i < 32; i++)
                {
                    if ((val & (1 << i)) != 0)
                    {
                        resByte |= ((1 << (31 - i)) & 0xFFFFFFFF);
                    }
                }

                return resByte;
            }

            this.ReflectGeneric = function (val, width)
            {
                var resByte = 0;

                for (var i = 0; i < width; i++)
                {
                    if ((val & (1 << i)) != 0)
                    {
                        resByte |= (1 << ((width-1) - i));
                    }
                }

                return resByte;
            }
        };

        /*
         * Get CRC model instance with given CRC width and given index (starting at 0, only counting entries with matching width
         */
        function getDataBaseEntryFromEntry(width, indexToFind)
        {
            var curIndex = 0;
            for (var i = 0; i < CrcDatabase.length; i++)
            {
                if (width != CrcDatabase[i].width) continue;
                if (curIndex == indexToFind)
                {
                    return CrcDatabase[i];
                }
                else
                {
                    curIndex++;
                }
            }
            throw "Invalid selected index into CRC database";
        }

        /*********************************************
         * GUI interaction
         *********************************************/
        /*
         * Retrieve selected CRC width
         */
        function getSelectedCrcWidth()
        {
            var selCrcWidth;
            if (document.getElementById('radiobuttoncrc8').checked)
            {
                selCrcWidth = 8;
            }
            else if (document.getElementById('radiobuttoncrc16').checked)
            {
                selCrcWidth = 16;
            }
            else if (document.getElementById('radiobuttoncrc32').checked)
            {
                selCrcWidth = 32;
            }
            else
            {
                throw "Invalid selected CRC width state";
            }
            return selCrcWidth;
        }

        /*
         * Convert the input data to byte array
         */
        function getInputData(inputText)
        {
            var stringUtil = new StringUtil();
            if (document.getElementById('radiobuttoninputdatastring').checked)
            {
                return stringUtil.getCharacterByteArrayFromString(inputText);
            }
            else if (document.getElementById('radiobuttoninputdatabytes').checked)
            {
                if (inputText.indexOf(' ') == -1 && inputText.length > 4)
                {
                    /* Hex workshop support which copes bytes without spaces */
                    var newText = "";
                    if (inputText.length % 2 != 0)
                    {
                        inputText = '0' + inputText;
                    }
                    for (var index = 0; index < inputText.length; index += 2)
                    {
                        newText += inputText.substr(index, 2);
                        newText += ' ';
                    }
                    newText = newText.substr(0, newText.length - 1);
                    document.getElementById("inputDataTextArea").innerHTML = newText;
                    return stringUtil.getCharacterByteArrayFromByteString(newText);
                }
                else
                {
                    return stringUtil.getCharacterByteArrayFromByteString(inputText);
                }
            }
            else
            {
                /* invalid state */
                return undefined;
            }
        }

        /*
         * Called when the calculate button is clicked
         */
        function calcButton_clicked()
        {
            /* at first get input data */
            var inputDataElem = document.getElementById("inputDataTextArea");
            var inputText = inputDataElem.value;
            var stringUtil = new StringUtil();
            var bytes = getInputData(inputText); //stringUtil.getCharacterByteArrayFromString(inputText);
            if (bytes == undefined)
            {
                printError("Invalid input data! Erroneous token: " + stringUtil.getLastErrorToken());
                return;
            }

            /* get selected CRC width */
            var selCrcWidth = getSelectedCrcWidth();

            /* request the CRC depending on the chosen settings */
            if (document.getElementById('radiobuttoninputpredefined').checked)
            {
                /* Predefined CRC selected */
                /* get selected CRC model parameters */
                var crcParams = getDataBaseEntryFromEntry(selCrcWidth, document.getElementById('selectpredefined').selectedIndex);

                calcAndDisplayCrc(selCrcWidth, crcParams, bytes);
            }
            else if (document.getElementById('radiobuttoninputcustom').checked)
            {
                /* custom CRC, get values from GUI elements */
                var crcModel = new CrcModel();
                crcModel.inputReflected = document.getElementById('checkboxInputReflected').checked;
                crcModel.resultReflected = document.getElementById('checkboxResultReflected').checked;

                var maxVal = 0xFFFFFFFF >>> (32 - selCrcWidth);

                crcModel.polynomial = parseInt(document.getElementById('textBoxPolynomial').value);
                if (crcModel.polynomial > maxVal)
                {
                    document.getElementById('textBoxPolynomial').value = stringUtil.getNumberAsHexStr(crcModel.polynomial & maxVal);
                }
                crcModel.initial = parseInt(document.getElementById('textBoxInitialValue').value);
                if (crcModel.initial > maxVal)
                {
                    document.getElementById('textBoxInitialValue').value = stringUtil.getNumberAsHexStr(crcModel.initial & maxVal);
                }
                crcModel.finalXor = parseInt(document.getElementById('textBoxFinalXorValue').value);
                if (crcModel.finalXor > maxVal)
                {
                    document.getElementById('textBoxFinalXorValue').value = stringUtil.getNumberAsHexStr(crcModel.finalXor & maxVal);
                }

                calcAndDisplayCrc(selCrcWidth, crcModel, bytes);
            }
            else
            {
                /* invalid state, do nothing */
            }
        }
        
        /* 
         * Calculate and display CRC value.
         */
        function calcAndDisplayCrc(selCrcWidth, crcParams, bytes)
        {
            var crc = new Crc(selCrcWidth, crcParams);
            var crcValue = crc.compute(bytes);
            printResultCrc(selCrcWidth, crcValue);
            printLookupTable(selCrcWidth, crc);            
        }

        /* Print crc value:
           - selCrcWidth: width of crc value in bits 
           - crcValue: actual CRC value 
        */
        function printResultCrc(selCrcWidth, crcValue)
        {
            if (selCrcWidth == 32)
            {
                /* special handling for printing 32bit required, otherwise interpreted as signed and actual string value is a negative number */
                document.getElementById('resultLabel').innerHTML =
                    '<span style="color:green">' + new StringUtil().getNumberAsHexStr32(crcValue) + '</span> ';
            }
            else
            {
                document.getElementById('resultLabel').innerHTML =
                    '<span style="color:green">' + new StringUtil().getNumberAsHexStr(crcValue) + '</span> ';
            }
        }

        /*
         * Print an error text.
         */
        function printError(errText)
        {
            document.getElementById('resultLabel').innerHTML =
                    '<span style="color:red">' + errText + '</span> ';
        }



</script>



<fieldset>
        <legend>CRC Input Data</legend>

        <input type="radio" id="radiobuttoninputdatastring" name="inputdataradiobutton" value="InputDataString"  />
        <label for="radiobuttoninputdatastring">String</label>

        <input type="radio" id="radiobuttoninputdatabytes" name="inputdataradiobutton" value="InputDataBytes" checked="checked"/>
        <label for="radiobuttoninputdatabytes">Bytes</label>
        <br />
        <textarea id="inputDataTextArea" cols="60" rows="3" style="margin: 4px;" >0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39</textarea>

</fieldset>
       
<br />
<button id="calcButton" onclick="calcButton_clicked();">Calculate CRC!</button>
<br />
<br />

<label style="font-weight:bold">Result CRC value: </label>
<label id="resultLabel" style="font-weight:bold"><span style="color:red">-</span> </label>



